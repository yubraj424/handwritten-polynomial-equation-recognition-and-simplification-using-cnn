# -*- coding: utf-8 -*-
"""WORKED_ONEpythonpolynomial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XHhKcjEC3siJtYlpdXuC1GxgE3I8U9Q5
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
import cv2
import glob
import matplotlib.pyplot as plt
from skimage import io

seed = 10
np.random.seed(seed)

#Input Images
PATH = '/content/drive/MyDrive/Hand written polynomial eqn detect/dataset'
trainImg =sorted(glob.glob('/content/drive/MyDrive/Hand written polynomial eqn detect/dataset/trainfinal/*'))
testImg= sorted(glob.glob(f"{PATH}//testfinal//*"))
eqImg=sorted(glob.glob(f"{PATH}//eqfinal//*"))
# eqImg=sorted(glob.glob('/content/drive/MyDrive/Hand written polynomial eqn detect/dataset/img3.jpeg'))

def Image_read(image):
  x = io.imread(image)
  x = cv2.cvtColor(x,cv2.COLOR_BGR2RGB) 
  return x

#Show training images
for images in trainImg:
  image = Image_read(images)
  plt.imshow(image)
  plt.show()

#Show test images
for images in testImg:
    image = Image_read(images)
    plt.imshow(image)
    plt.show()

#Show equation image
for images in eqImg:
    image = Image_read(images)
    plt.imshow(image)
    plt.show()

finallist=[]

#another list for no padding in the end
flistNoPad=[]
for images in trainImg:
    image = Image_read(images)
    pixel_values = image.reshape((-1, 3))
    
    # convert to float
    pixel_values = np.float32(pixel_values)
    #K means with k=2
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
    k = 2
    _, labels, (centers) = cv2.kmeans(pixel_values, k, None,criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
    centers = np.uint8(centers)
    centers2=np.uint8([[255,255,255],[0,0,0]])
    # flatten the labels array
    labels = labels.flatten()
    segmented_image = centers2[labels.flatten()]
    segmented_image = segmented_image.reshape(image.shape)
    # show the image
    if(segmented_image[0,0,0]!=0):
        segmented_image=~segmented_image
    plt.imshow(segmented_image)
    plt.show()
    img=segmented_image
    flag=0
    first=0
    last=0
    imglist=[]
    flag2=0
    firstfr=0
    
    #This for loop separates the segmented digits and operations
    for i in range(img.shape[1]-6):
        if np.sum(img[:,i,0])==0 :
            if np.sum(img[:,firstfr+6,0])==0 :
                flag2=0
            if np.sum(img[:,firstfr+6,0])!=0 :
                if flag==1:
                    if np.sum(img[:,i+4,0])==0:
                        last=i
                        #cut here on right on middle +5
                        imglist.append(img[:,first:last+2,:])
                        first=i+2
                        flag2=0
                        flag=0

                continue
        if np.sum(img[:,i,0])!=0:
            if flag2==0:
                firstfr=i
            flag2=1
            flag=1
            continue
    #this for loop remove border black pixels to center the digits       
    for m in range(len(imglist)):       
        var0=np.var(imglist[m][:,:,0],axis=0)
        var1=np.var(imglist[m][:,:,0],axis=1)
        #to not remove indices from middle(for ''='' case)
        indices0=[i for i in list(range(len(var0))) if var0[i]==0]
        indices1=[i for i in list(range(len(var1)-5)) if var1[i]==0 and np.sum(var1[i+5])==0]
        temp0=imglist[m]
        temp0=np.delete(temp0,indices0,axis=1)
        temp0=np.delete(temp0,indices1,axis=0)
        flistNoPad.append(temp0)
        temp0=np.pad(temp0[:,:,0],pad_width=10,mode='constant',constant_values=0)
        temp0=np.repeat(temp0[:,:,np.newaxis],3,axis=2)
        plt.imshow(temp0)
        plt.show()
        finallist.append(temp0)

len(finallist)

#training label
y_train=[0,0,0,0,0,0,0,0,8,8,8,3,4,9,2,13,13,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,10,10,10,10,10,10,10,10,10,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,1,1,4,4,4,4,9,10,10,10,11,11,11,13,13,1,1,1,12,12,12,4,5,6,7,8,9,1,0,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,3,8,8,3,6,6,6,6,6,6,8,3,8,7,7,7,7,7,7,8,8,9,9,9,9,9,0,1,2,3,4,5,6,7,8,9,12,13,13,3,4,4,5,6,10,11,10,11,8,9,12,13,13,3,4]

len(y_train)

testlist=[]

#another data for no padding in the end
testnopadlist=[]
for images in testImg:
    image = Image_read(images)
    pixel_values = image.reshape((-1, 3))
    # convert to float
    pixel_values = np.float32(pixel_values)
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
    k = 2
    _, labels, (centers) = cv2.kmeans(pixel_values, k, None,criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
    centers = np.uint8(centers)
    centers2=np.uint8([[255,255,255],[0,0,0]])
    # flatten the labels array
    labels = labels.flatten()
    segmented_image = centers2[labels.flatten()]
    segmented_image = segmented_image.reshape(image.shape)
    # show the image
    if(segmented_image[0,0,0]!=0):
        segmented_image=~segmented_image
    plt.imshow(segmented_image)
    plt.show()
    img=segmented_image
    flag=0
    #only R from RGB
    first=0
    last=0
    imglist=[]
    flag2=0
    firstfr=0
    #1269 since i+10 in loop
    for i in range(img.shape[1]-6):
        if np.sum(img[:,i,0])==0 :
            if np.sum(img[:,firstfr+6,0])==0 :
                flag2=0
            if np.sum(img[:,firstfr+6,0])!=0 :
                if flag==1:
                    if np.sum(img[:,i+4,0])==0:
                        last=i
                        #cut here on right on middle +5
                        imglist.append(img[:,first:last+2,:])
                        first=i+2
                        flag2=0
                        flag=0

                continue
        if np.sum(img[:,i,0])!=0:
            if flag2==0:
                firstfr=i
            flag2=1
            flag=1
            continue
    for m in range(len(imglist)):       
        var0=np.var(imglist[m][:,:,0],axis=0)
        var1=np.var(imglist[m][:,:,0],axis=1)
        middle=len(var1)
        indices0=[i for i in list(range(len(var0))) if var0[i]==0]
        indices1=[i for i in list(range(len(var1)-5)) if var1[i]==0 and np.sum(var1[i+5])==0]
        temp0=imglist[m]
        temp0=np.delete(temp0,indices0,axis=1)
        temp0=np.delete(temp0,indices1,axis=0)
        testnopadlist.append(temp0)
        temp0=np.pad(temp0[:,:,0],pad_width=10,mode='constant',constant_values=0)
        temp0=np.repeat(temp0[:,:,np.newaxis],3,axis=2)
        plt.imshow(temp0)
        plt.show()
        testlist.append(temp0)

#test labels
y_test=[0,1,2,3,4,5,6,7,8,9,10,11,12,13]

eqlist=[] #equation list

#another data for no padding in the end
eqnopadlist=[]
for images in eqImg:
    image = Image_read(images)
    pixel_values = image.reshape((-1, 3))
    # convert to float
    pixel_values = np.float32(pixel_values)
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
    k = 2
    _, labels, (centers) = cv2.kmeans(pixel_values, k, None,criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
    centers = np.uint8(centers)
    centers2=np.uint8([[255,255,255],[0,0,0]])
    # flatten the labels array
    labels = labels.flatten()
    segmented_image = centers2[labels.flatten()]
    segmented_image = segmented_image.reshape(image.shape)
    # show the image
    if(segmented_image[0,0,0]!=0):
        segmented_image=~segmented_image
    plt.imshow(segmented_image)
    plt.show()
    img=segmented_image
    flag=0
    #only R from RGB
    first=0
    last=0
    imglist=[]
    flag2=0
    firstfr=0
    #1269 since i+10 in loop
    for i in range(img.shape[1]-6):
        if np.sum(img[:,i,0])==0 :
            if np.sum(img[:,firstfr+6,0])==0 :
                flag2=0
            if np.sum(img[:,firstfr+6,0])!=0 :
                if flag==1:
                    if np.sum(img[:,i+4,0])==0:
                        last=i
                        #cut here on right on middle +5
                        imglist.append(img[:,first:last+2,:])
                        first=i+2
                        flag2=0
                        flag=0

                continue
        if np.sum(img[:,i,0])!=0:
            if flag2==0:
                firstfr=i
            flag2=1
            flag=1
            continue
    for m in range(len(imglist)):       
        var0=np.var(imglist[m][:,:,0],axis=0)
        var1=np.var(imglist[m][:,:,0],axis=1)
        middle=len(var1)
        indices0=[i for i in list(range(len(var0))) if var0[i]==0]
        indices1=[i for i in list(range(len(var1)-5)) if var1[i]==0 and np.sum(var1[i+5])==0]
        temp0=imglist[m]
        temp0=np.delete(temp0,indices0,axis=1)
        temp0=np.delete(temp0,indices1,axis=0)
        eqnopadlist.append(temp0)
        temp0=np.pad(temp0[:,:,0],pad_width=10,mode='constant',constant_values=0)
        temp0=np.repeat(temp0[:,:,np.newaxis],3,axis=2)
        plt.imshow(temp0)
        plt.show()
        eqlist.append(temp0)

#equations label 
eq_test=[4,13,3,11,8,12,3,13,2,10,9,13]
# eq_test=[7,13,3,10,6,12,2,13,2,11,5,13]

leng=len(finallist)
nRows=np.array([k.shape[0] for k in finallist])
nCols=np.array([k.shape[1] for k in finallist])
flistNoPad=flistNoPad
leng2=len(flistNoPad)
nRows2=np.array([k.shape[0] for k in flistNoPad])
nCols2=np.array([k.shape[1] for k in flistNoPad])

#resizing
dsize = (80, 150)
dsizenopad=(64,64)
temp=finallist
temp2=flistNoPad
testtemp=testlist
testtemp2=testnopadlist
eqtemp=eqlist
eqtemp2=eqnopadlist

# resize image
for i in range(leng):
    temp[i] = cv2.resize(finallist[i], dsize)
for i in range(leng2):
    temp2[i] = cv2.resize(flistNoPad[i], dsizenopad)   
for i in range(len(testtemp)):
    testtemp[i] = cv2.resize(testlist[i], dsize)  
for i in range(len(testtemp2)):
    testtemp2[i] = cv2.resize(testnopadlist[i], dsizenopad) 
for i in range(len(eqtemp)):
    eqtemp[i] = cv2.resize(eqlist[i], dsize)  
for i in range(len(eqtemp2)):
    eqtemp2[i] = cv2.resize(eqnopadlist[i], dsizenopad)

train=temp
test=testtemp
train2=temp2
test2=testtemp2
eq=eqtemp
eq2=eqtemp2

train2 = np.array(train2) 
test2 = np.array(test2)

train2.shape

# For training list

import tensorflow as tf
y_train_2D = tf.keras.utils.to_categorical(y_train ,num_classes=14)

y_train_2D.shape

# For Testing list

y_test_2D = tf.keras.utils.to_categorical(y_test ,num_classes=14)

y_test_2D.shape

test2.shape

from tensorflow.python.keras.models import Sequential
from tensorflow.python.keras.layers import Dense, Convolution2D, MaxPooling2D, Flatten, Dropout 


def make_model():
    model = Sequential()

    #CNN Layers
    model.add(Convolution2D(32, (3,3), input_shape = (64,64,3)))
    model.add(MaxPooling2D ((2,2)))
    model.add(Convolution2D(32, (3,3), input_shape = (64,64,3)))
    model.add(MaxPooling2D ((2,2)))
    model.add(Convolution2D(32, (3,3), input_shape = (64,64,3)))
    model.add(MaxPooling2D ((2,2)))
    
    model.add(Flatten())
    
    #Hidden ANN Layers
    model.add(Dense(units = 128, kernel_initializer = "random_uniform", activation ="relu"))
    model.add(Dropout(0.5))

    model.add(Dense(units = 128, kernel_initializer = "random_uniform", activation ="relu"))
    model.add(Dropout(0.3)) 

    #Output Layer
    model.add(Dense(units = 14, kernel_initializer = "random_uniform", activation ="softmax"))

    #Compile and save
    model.compile(optimizer = "adam", loss = "categorical_crossentropy", metrics = ["accuracy"])
    model.save('PolyEqSolver.h5')

    return model

if __name__ == "__main__":
    model = make_model()
    model.summary()

import warnings 
from tensorflow.keras.models import load_model 

# CNN Model 
model = load_model('/content/PolyEqSolver.h5')
warnings.filterwarnings("ignore")

# # Early Stopping
# from tensorflow.keras.callbacks import EarlyStopping
# early_stop = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=5)

hist = model.fit(
    train2, y_train_2D, 
    batch_size=64, 
    epochs = 30,
    shuffle = True,
    verbose = 1, 
    # callbacks=[early_stop],
    validation_data=(test2, y_test_2D)
)

# Plotting
import matplotlib.pyplot as plt

plt.figure(figsize = (8,8))

# PLOT CROSS ENTROPY LOSS
plt.title('Cross Entropy Loss')
plt.plot(hist.history['loss'], color='blue', label='train')
plt.plot(hist.history['val_loss'], color='orange', label='test')

# PLOT CLASSIFICATION ACCURACY

plt.figure(figsize = (8,8))

plt.title('Classification Accuracy')
plt.plot(hist.history['accuracy'], color='blue', label='train')
plt.plot(hist.history['val_accuracy'], color='orange', label='test')

# Convert the 2D array of x test data into 1d format such as 0,1,2, etc

y_pred = [] 

for pred in model.predict(test2): 
    y_pred.append(np.where(pred == max(pred))[0][0])

# Convert the 2D array of x train data into 1d format such as 0,1,2, etc

y_true = [] 

for data in y_test_2D: 
    y_true.append(np.where(data == max(data))[0][0])

# plot confusion matrix

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay 

fig, ax = plt.subplots(figsize=(10, 10)) 

cm = confusion_matrix(y_true, y_pred) 
disp = ConfusionMatrixDisplay(confusion_matrix= cm)
disp.plot(cmap = 'gnuplot',ax = ax) 

plt.show()

# Prediction with true value image

from numpy.random import randint 

rand_index = randint(0, len(y_pred)) 
plt.imshow(test2[rand_index])

if y_pred[rand_index] < 10:
    print('CNN Model Prediction: ', y_pred[rand_index])
     
else: 
    if y_pred[rand_index] == '10': 
        print('CNN Model Prediction: +') 
        
    if y_pred[rand_index] == '11': 
        print('CNN Model Prediction: -')
        
    if y_pred[rand_index] == '12': 
        print('CNN Model Prediction: =')
    
    if y_pred[rand_index] == '13': 
        print('CNN Model Prediction: X')

# Converting list to numpy array for prediction purposes 
eq2_cnn = np.array(eq2)

eq2_cnn.shape

#Flattening the images array
newtrainlist=[k[:,:,0] for k in train]
newtestlist=[k[:,:,0] for k in test]
newtrainlist2=[k[:,:,0] for k in train2]
newtestlist2=[k[:,:,0] for k in test2]
neweqlist=[k[:,:,0] for k in eq]
neweqlist2=[k[:,:,0] for k in eq2]

newtrainlist=[k.flatten() for k in newtrainlist]
newtestlist=[k.flatten() for k in newtestlist]
newtrainlist2=[k.flatten() for k in newtrainlist2]
newtestlist2=[k.flatten() for k in newtestlist2]
neweqlist=[k.flatten() for k in neweqlist]
neweqlist2=[k.flatten() for k in neweqlist2]

x_train = np.vstack(newtrainlist)
print((x_train.shape))
x_test=np.vstack(newtestlist)
print((x_test.shape))

x_train2 = np.vstack(newtrainlist2)
x_test2=np.vstack(newtestlist2)
print((x_train2.shape))
print((x_test2.shape))
x_eq=np.vstack(neweqlist)
x_eq2=np.vstack(neweqlist2)

x_eq2

#Over sampling (did not help much with acuracy)
from imblearn.over_sampling import RandomOverSampler
ros = RandomOverSampler(random_state=0)
x_resampled, y_resampled = ros.fit_resample(x_train, y_train)

#Dividing the pixel values by 255 to get only 0 and 1 values in the input arrays 
def fn(x):
    if(x==0):
        return 0
    else :
        return 1
fn=np.vectorize(fn)    
x_train3=fn(x_train)
x_train4=fn(x_train2)
x_test3=fn(x_test)
x_test4=fn(x_test2)
x_eq3=fn(x_eq)
x_eq4=fn(x_eq2)

#equation image correct labels
print(eq_test)

# #Logistic Model
# from sklearn.linear_model import LogisticRegression
# lr = LogisticRegression(multi_class= 'multinomial',random_state=1)
# lr.fit(x_train2, y_train)

# # Testing and Training accuracy using Logistic Regression
# print(lr.score(x_test2,y_test))
# print(lr.score(x_eq2,eq_test))

import math
import cmath
import numpy as np 

#Mapping labels to their digits and operations
dic={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,10:'+',11:'-',12:'=',13:'x'}

#print equation 
def printEq(x):
    detected_eq = [] 
    flag=0
    for i in range(len(x)):
        if flag==1:
            flag=0
            continue
        if i!=len(x)-1 and dic[x[i]]=='x'and x[i+1]!=10 and x[i+1]!=11 and x[i+1]!=12:
            print('x^'+str(dic[x[i+1]]), end=" ")
            detected_eq.append('x^'+str(dic[x[i+1]])) 
            flag=1
        else :
            print(dic[x[i]], end=" ")
            detected_eq.append(str(dic[x[i]]))
    
    return ' '.join(detected_eq)

# Find degree of polynomial
def highdegree(x):
    Max=1
    for i in range(len(x)):
        if i!=len(x)-1 and x[i]==13 and x[i+1]!=10 and x[i+1]!=11 and x[i+1]!=12:
            Max=max(Max,x[i+1])
    return Max     

# Helper function to return float value of f.
def findF(a, b, c):
    return ((3.0 * c / a) - ((b ** 2.0) / (a ** 2.0))) / 3.0


# Helper function to return float value of g.
def findG(a, b, c, d):
    return (((2.0 * (b ** 3.0)) / (a ** 3.0)) - ((9.0 * b * c) / (a **2.0)) + (27.0 * d / a)) /27.0


# Helper function to return float value of h.
def findH(g, f):
    return ((g ** 2.0) / 4.0 + (f ** 3.0) / 27.0)

def cubic_solver(a, b, c, d):

    if (a == 0 and b == 0):                     # Case for handling Liner Equation
        return np.array([(-d * 1.0) / c])                 # Returning linear root as numpy array.

    elif (a == 0):                              # Case for handling Quadratic Equations

        D = c * c - 4.0 * b * d                       # Helper Temporary Variable
        if D >= 0:
            D = math.sqrt(D)
            x1 = (-c + D) / (2.0 * b)
            x2 = (-c - D) / (2.0 * b)
        else:
            D = math.sqrt(-D)
            x1 = (-c + D * 1j) / (2.0 * b)
            x2 = (-c - D * 1j) / (2.0 * b)
            
        return np.array([x1, x2])               # Returning Quadratic Roots as numpy array.

    f = findF(a, b, c)                          # Helper Temporary Variable
    g = findG(a, b, c, d)                       # Helper Temporary Variable
    h = findH(g, f)                             # Helper Temporary Variable

    if f == 0 and g == 0 and h == 0:            # All 3 Roots are Real and Equal
        if (d / a) >= 0:
            x = (d / (1.0 * a)) ** (1 / 3.0) * -1
        else:
            x = (-d / (1.0 * a)) ** (1 / 3.0)
        return np.array([x, x, x])              # Returning Equal Roots as numpy array.

    elif h <= 0:                                # All 3 roots are Real

        i = math.sqrt(((g ** 2.0) / 4.0) - h)   # Helper Temporary Variable
        j = i ** (1 / 3.0)                      # Helper Temporary Variable
        k = math.acos(-(g / (2 * i)))           # Helper Temporary Variable
        L = j * -1                              # Helper Temporary Variable
        M = math.cos(k / 3.0)                   # Helper Temporary Variable
        N = math.sqrt(3) * math.sin(k / 3.0)    # Helper Temporary Variable
        P = (b / (3.0 * a)) * -1                # Helper Temporary Variable

        x1 = 2 * j * math.cos(k / 3.0) - (b / (3.0 * a))
        x2 = L * (M + N) + P
        x3 = L * (M - N) + P

        return np.array([x1, x2, x3])           # Returning Real Roots as numpy array.

    elif h > 0:                                 # One Real Root and two Complex Roots
        R = -(g / 2.0) + math.sqrt(h)           # Helper Temporary Variable
        if R >= 0:
            S = R ** (1 / 3.0)                  # Helper Temporary Variable
        else:
            S = (-R) ** (1 / 3.0) * -1          # Helper Temporary Variable
        T = -(g / 2.0) - math.sqrt(h)
        if T >= 0:
            U = (T ** (1 / 3.0))                # Helper Temporary Variable
        else:
            U = ((-T) ** (1 / 3.0)) * -1        # Helper Temporary Variable

        x1 = (S + U) - (b / (3.0 * a))
        x2 = -(S + U) / 2 - (b / (3.0 * a)) + (S - U) * math.sqrt(3) * 0.5j
        x3 = -(S + U) / 2 - (b / (3.0 * a)) - (S - U) * math.sqrt(3) * 0.5j

        return np.array([x1, x2, x3])           # Returning One Real Root and two Complex Roots as numpy array.

def quadratic_solver(a,b,c): 

    # calculate the discriminant
    d = (b**2) - (4*a*c)

    # find two solutions
    sol1 = (-b-cmath.sqrt(d))/(2*a)
    sol2 = (-b+cmath.sqrt(d))/(2*a)

    return np.array([sol1, sol2])

def linear_solver(a,b): 
    
    # ax + b = 0 
    
    return -b/a 

def changeSign(index,x): 
    nums = [0,1,2,3,4,5,6,7,8,9]
    
    for i in range(len(x)): 
    
        if i > index: 
            if x[i] in nums: 
                if x[i-1] == 10: 
                    x[i] = -1*x[i] 

        elif i == index: 
            if x[i] in nums: 
                x[i] = -1*x[i] 

        elif i < index: 
            if x[i] in nums: 
                if x[i-1] == 11: 
                    x[i] = -1*x[i]   

def polyEqSolver(x): 
    detected_eq = printEq(x)
    print('\n ------------------------------\n')
    degree=highdegree(x)
    #equality index
    ind=0
    for i in x:
        if i==12:
            break
        ind=ind+1   
     
    print('Old x:', x)
    x=x[0:ind]+x[ind+1:len(x)] 
    print('New x: ', x) 
    
    #Finding Degree of Polynomial 
    
    degree = highdegree(x) 
    print()
    print('Degree of Polynomial : ', degree) 
    print('\n ------------------------------\n')
    
    #-------------------------------------
    
    changeSign(ind, x) 
    
    print('New x (with sign changes): ', x) 
    print('\n ------------------------------\n')
    
    
    # ------------------------------------
    #Checking degrees of all X's in the equation 
    
    x_degs = [(i-1, x[i-1], x[i+1]) for i, deg in enumerate(x) if (deg == 13 and i !=len(x) - 1 and i!=0)]
    
    #If any of the X doesn't have degree written explicitly (That is, degree = 1) 
    x_degs = x_degs + [(i-1, x[i-1] ,1) for i, deg in enumerate(x) if (deg == 13 and (i == len(x) - 1 or x[i+1] >=10))]

    # If any of X doesn't have coeff written explicitly (That is, coeff = 1) 
    x_degs = x_degs + [(i-1, 1 ,x[i+1]) for i, deg in enumerate(x) if (deg == 13 and (i == 0 or x[i-1] >=10))]

    
    for deg_data in x_degs:
        print('Index of Coefficient: ',  deg_data[0]) 
        print('Coefficient: ', deg_data[1])
        print('Degree: ', deg_data[2]) 
        print() 
        
    print('------------------------------\n') 
    
    # Finding Final Coefficients of Polynomial Equation 
    
    constant = 0
    eq_coeffs = [] 
    
    for k in range(degree + 1): 
        
        #For Constant
        if k == 0: 
            for i, deg in enumerate(x):              
                if deg <10:
                    flag = False 
                    for deg_data in x_degs: 
                        if i == deg_data[0]: 
                            flag = True 
                            break 
                    
                    if flag == False and x[i-1] !=13: 
                        constant += deg 
        
        #For powers of X  
        else: 
            
            coeff_sum = 0 
            for deg_data in x_degs: 
                if deg_data[2] == k: 
                    coeff_sum += deg_data[1] 
            
            eq_coeffs.append(coeff_sum) 
        
    print('Constant: ', constant) 
    print('Coeffs of Equation: ', eq_coeffs) 
        
    print('------------------------------\n') 
    
    #Putting in appropriate Polynomial Solver 
    
    print('Roots of equations are :')
    print('\n')
    
    
    #Linear 
    if k == 1:
        result = [
        
         detected_eq, 
         
          str(linear_solver(a=eq_coeffs[0], b = constant)) ,
        ] 

        return ''.join(result)
        # print(result)
    
    #Quadratic
    if k == 2:
        roots =  quadratic_solver(a=eq_coeffs[1], b = eq_coeffs[0], c = constant)
        roots = [str(x) for x in roots] 

        result = [
        
        detected_eq, 
       
          roots[0] , 
          roots[1] , 
        
        ]

        return ''.join(result)
        # print(result)
    #Cubic
    if k == 3: 
        roots =  cubic_solver(a = eq_coeffs[2], b = eq_coeffs[1], c = eq_coeffs[0], d = constant)
        roots = [str(x) for x in roots] 

        result = [
             detected_eq, 
            
           roots[0],
            roots[1], 
            roots[2] ,
        ]

        return ''.join(result)
        # print(result)

def get_pred(model, x):     
    '''
    Function used to output the predicted numerical label from a 2D array. 
    
    model -> Your ML model 
    x -> The data you want to predict on 
    
    '''
    y_pred = [] 

    for pred in model.predict(x): 
        y_pred.append(np.where(pred == max(pred))[0][0]) 
    
    return y_pred

# CNN Prediction Labels
cnn_preds = np.array(get_pred(model, eq2_cnn))
cnn_preds

#Final Output 
polyEqSolver(list(cnn_preds))

